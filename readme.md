Порівняння ефективності жадібного та динамічного алгоритмів програмування
У цьому завданні реалізовано два підходи до видачі решти:
жадібний алгоритм та алгоритм динамічного програмування (DP).
Обидва повертають коректний набір монет, але їхня продуктивність суттєво відрізняється.

ЖАДІБНИЙ АЛГОРИТМ
1.1 Складність
Часова складність: 
O(n)- де n — кількість номіналів монет (у нашому випадку n = 6, тобто константа).
Просторова складність: O(1)
Поведінка на великих сумах.
Жадібний алгоритм працює дуже швидко, оскільки:- він просто проходить список монет один раз;
- для кожного номіналу виконує лише ділення та віднімання;
- кількість операцій не залежить від суми.
Навіть для сум у мільйони або мільярди алгоритм працює практично миттєво. 
1.2 Переваги:
- максимальна швидкість.
- мінімальне використання пам’яті.
- простота реалізації.
1.3 Недоліки:
- працює оптимально лише для "канонічних" систем монет. 
У канонічній системі монет номінали підібрані так, що:
- більші монети добре «узгоджуються» з меншими,
- не існує суми, для якої жадібний алгоритм вибере неправильну комбінацію.
(Для нашого набору монет — працює ідеально.)
АЛГОРИТМ ДИНАМІЧНОГО ПРОГРАМУВАННЯ (DP)
1.1 Складність:
Часова складність: O(n× S)- де S — сума, для якої шукаємо решту.
Просторова складність: O(S)
Поведінка на великих сумах
DP будує таблицю розміром S + 1, отже:
- час виконання зростає лінійно зі збільшенням суми;
- пам’ять також зростає пропорційно сумі.
При сумах у десятки тисяч алгоритм працює помітно повільніше.
При сумах у сотні тисяч або мільйони — стає практично непридатним через великі витрати пам’яті та часу.
1.2 Переваги:
- завжди знаходить мінімальну кількість монет;
- працює для будь-яких систем монет, навіть "неправильних".
1.3 Недоліки:
- значно повільніший за жадібний алгоритм.
- споживає більше пам’яті.
- погано масштабується на великі суми.

ПРАКТИЧНЕ ПОРІВНЯННЯ (10 000 ЗАПУСКІВ)
Жадібний алгоритм виявився приблизно у 20–30 разів швидшим.
ВИСНОВКИ
1.1 Жадібний алгоритм є значно ефективнішим за часом і пам’яттю.
Його продуктивність не залежить від величини суми, тому він ідеально підходить для касових апаратів.
1.2 Алгоритм динамічного програмування гарантує мінімальну кількість монет, але його продуктивність погіршується зі збільшенням суми. Він підходить для задач, де оптимальність важливіша за швидкість (наприклад, фінансові оптимізації, нестандартні набори монет).
1.3 Для нашої системи монет (50, 25, 10, 5, 2, 1) жадібний алгоритм завжди дає оптимальний результат, тому використання DP не має практичних переваг.
