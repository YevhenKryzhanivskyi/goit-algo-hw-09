Порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування
У цьому завданні реалізовано два підходи до видачі решти:
жадібний алгоритм та алгоритм динамічного програмування (DP).
Обидва повертають коректний набір монет, але їхня продуктивність суттєво відрізняється.

✅ Жадібний алгоритм
Складність
- Часова складність:
O(n)- де n — кількість номіналів монет (у нашому випадку n = 6, тобто константа).
- Просторова складність:
O(1)Поведінка на великих сумахЖадібний алгоритм працює дуже швидко, оскільки:- він просто проходить список монет один раз;
- для кожного номіналу виконує лише ділення та віднімання;
- кількість операцій не залежить від суми.
Навіть для сум у мільйони або мільярди алгоритм працює практично миттєво.Переваги- Максимальна швидкість.
- Мінімальне використання пам’яті.
- Простота реалізації.
Недоліки- Працює оптимально лише для "канонічних" систем монет.
(Для нашого набору монет — працює ідеально.)
✅ Алгоритм динамічного програмування (DP)Складність- Часова складність:
O(n\cdot S)- де S — сума, для якої шукаємо решту.
- Просторова складність:
O(S)Поведінка на великих сумахDP будує таблицю розміром S + 1, тому:- час виконання зростає лінійно зі збільшенням суми;
- пам’ять також зростає пропорційно сумі.
При сумах у десятки тисяч алгоритм працює помітно повільніше.
При сумах у сотні тисяч або мільйони — стає практично непридатним через великі витрати пам’яті та часу.Переваги- Завжди знаходить мінімальну кількість монет.
- Працює для будь-яких систем монет, навіть "неправильних".
Недоліки- Значно повільніший за жадібний алгоритм.
- Споживає більше пам’яті.
- Погано масштабується на великі суми.
✅ Практичне порівняння (10 000 запусків)|  |  | 
|  |  | 
|  |  | 

Жадібний алгоритм виявився приблизно у 20–30 разів швидшим.✅ Висновки- Жадібний алгоритм є значно ефективнішим за часом і пам’яттю.
Його продуктивність не залежить від величини суми, тому він ідеально підходить для касових апаратів, POS‑терміналів та інших систем реального часу.
- Алгоритм динамічного програмування гарантує мінімальну кількість монет, але його продуктивність погіршується зі збільшенням суми.
Він підходить для задач, де оптимальність важливіша за швидкість (наприклад, фінансові оптимізації, нестандартні набори монет).
- Для нашої системи монет (50, 25, 10, 5, 2, 1) жадібний алгоритм завжди дає оптимальний результат, тому використання DP не має практичних переваг.
